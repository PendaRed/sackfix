package org.sackfix.codegen

import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import scala.collection.mutable.ArrayBuffer

/**
  * Created by Jonathan during 2016.
  */
object SfCodeGeneratorField {
  def generateFieldType(fieldDet:FixFieldDetail) : String = {
    fieldDet.fieldType match {
      case "AMT" | "FLOAT" | "PERCENTAGE" | "PRICE" | "PRICEOFFSET" | "QTY" => "Float"
      case "BOOLEAN" => "Boolean"
      case "CHAR" => "String" //"Char"  It turns out that MassCancelRejectReason has a valid value of 99 - so its not a char at all.  Stupid Fix.
      case "COUNTRY" | "CURRENCY" | "DATA" | "EXCHANGE" | "LANGUAGE" |
           "MULTIPLECHARVALUE" | "MULTIPLEVALUESTRING" | "STRING" | "XMLDATA" |
           "MULTIPLESTRINGVALUE"=> "String"
      case "INT" | "LENGTH" | "NUMINGROUP" | "SEQNUM" | "DAYOFMONTH" | "DAY-OF-MONTH" => "Int"
      case "TZTIMEONLY" => "OffsetTime" // HH:MM[:SS][Z[ +- hh[:mm]]]     ISO 8601
      case "TZTIMESTAMP" => "OffsetDateTime" // YYYYMMDD-HH:MMM:SS.sss*[Z[ + - hh[:mm]]]   ISO 8601
      case "LOCALMKTDATE" | "DATE" => "LocalDate" // YYYMMDD  where YYYY=0000-9999 MM=01-12 DD=01-31
      case "MONTHYEAR" | "MONTH-YEAR" => "LocalDate" // Valid forms are YYYMMM  YYYYMMDD YYYYMMWW where WW can be w1,w2,w3,w4,w5
      case "UTCDATE" | "UTCDATEONLY" => "LocalDate" // YYYMMDD  where YYYY=0000-9999 MM=01-12 DD=01-31
      case "UTCTIMEONLY" => "LocalTime" // HH:MM:SS or HH:MM:SS.sss    HH=0-24, MM=00-50, SS=00-60,sss
      case "UTCTIMESTAMP" | "TIME" => "LocalDateTime" // YYYYMMDD-HH:MM:SS or YYYYMMDD-HH:MM:SS.sss
    }
  }
}

class SfCodeGeneratorField(val packageName:String, val fieldDet:FixFieldDetail) {

  /**
    * For a field definition this generates the full class file.
    */
  def generateFieldClassStr : String = {
    val fldVals = fieldDet.subElements.collect({ case fvv:FixValueDetail => fvv })
    val cname=fieldDet.name+"Field"

    val valuePart = {if (generateFieldType=="Boolean") """{if (value) "Y" else "N"}""" else "value"}

    generateFileHeader +
      s"case class $cname(override val value: $generateFieldType)" +
      s" extends $generateSuperClass(${fieldDet.number}, value) {\n" +
      "  override def toString = appendStringBuilder().toString\n" +
      "  override def appendStringBuilder(b:StringBuilder = new StringBuilder()) = b.append(\"(" +fieldDet.number+")"+fieldDet.name+
      "=(\").append("+valuePart+").append(\")\")" + {if (fldVals.isEmpty)"" else ".append("+cname+".fixDescriptionByValue.getOrElse("+valuePart+",\"\"))"}+"\n" +
    s"}\n$generateObjectConstants"
  }

  private def generateFileHeader :String = {
    s"""package $packageName
       |
       |$generateImports
       |/**
       |  * Generated by SackFix code generator on ${DateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now())}
       |  */
       |""".stripMargin
  }

  private def generateImports :String = {
    s"import org.sackfix.common.validated.fields.$generateSuperClass\n"+ {
      fieldDet.fieldType match {
        case "TZTIMEONLY" => //"OffsetTime" // HH:MM[:SS][Z[ +- hh[:mm]]]     ISO 8601
          """import java.time.OffsetTime
          |import org.sackfix.common.validated.fields.SfFixDateFormats
          |"""
        case "TZTIMESTAMP" => //"OffsetDateTime" // YYYYMMDD-HH:MMM:SS.sss*[Z[ + - hh[:mm]]]   ISO 8601
          """import java.time.OffsetDateTime
          |import org.sackfix.common.validated.fields.SfFixDateFormats
          |"""
        case "LOCALMKTDATE" | "DATE" | "MONTHYEAR" | "MONTH-YEAR" | "UTCDATE" | "UTCDATEONLY"  => //"LocalDate"
          """import java.time.LocalDate
          |import org.sackfix.common.validated.fields.SfFixDateFormats
          |"""
        case "UTCTIMEONLY" =>
          """import java.time.LocalTime
            |import org.sackfix.common.validated.fields.SfFixDateFormats
            |"""
        case "UTCTIMESTAMP" | "TIME" => // "LocalDateTime" // YYYYMMDD-HH:MM:SS or YYYYMMDD-HH:MM:SS.sss
          """import java.time.LocalDateTime
          |import org.sackfix.common.validated.fields.SfFixDateFormats
          |"""
        case _ => ""
      }
    }
  }


  private def generateObjectConstants : String = {
    s"""
       |object ${fieldDet.name}Field {
       |  val TagId = ${fieldDet.number} $generateObjectConstantsForEnums $generateApplyAndDecode
       |}\n""".stripMargin

    // changed to be case classes, so defaul apply is generated for us
    //        |  apply(val value: ${generateFieldType(fieldDet)}) = new ${fieldDet.name}(value)
  }

  private def generateObjectConstantsForEnums :String = {
//    val fldVals1: Seq[FixValueDetail] = fieldDet.subElements.filter(_.isInstanceOf[FixValueDetail]).
//      map(_.asInstanceOf[FixValueDetail])
    val fldVals: ArrayBuffer[FixValueDetail] = fieldDet.subElements.collect({ case fvv:FixValueDetail => fvv })

    val delim = getFieldValueTypeDelimter
    if (fldVals.isEmpty) ""
    else {
      "\n"+
        fldVals.map { valDet =>
          s"  val ${SfCodeGenUtils.makeUpperCamelCase(valDet.desc)}=$delim${valDet.name}$delim\n"
        }.mkString +
        "  lazy val fixDescriptionByValue = Map(" + {
        fldVals.zipWithIndex.map {
          case (valDet: FixValueDetail, index: Int) => {
            if (index > 0) "," else ""
          } + {
            if ((index + 1) % 3 == 0) "\n    " else ""
          } +
            delim + valDet.name + delim + "->\"" + valDet.desc + "\""
        }.mkString
      } + ")\n"
    }

  }

  private def getFieldValueTypeDelimter : String = {
    generateFieldType match {
      case "Char" => "'"
      case "String" | "Boolean" => "\""
      case _ => ""
    }
  }

  private def generateFieldType : String = {
    SfCodeGeneratorField.generateFieldType(fieldDet)
  }

  private def generateSuperClass : String = {
    fieldDet.fieldType match {
      case "AMT" | "FLOAT" | "PERCENTAGE" | "PRICE" | "PRICEOFFSET" | "QTY" => "SfFieldFloat"
      case "BOOLEAN" => "SfFieldBoolean"
      case "CHAR" => "SfFieldString" // "SfFieldChar"  - turns out some char fields actually contain strings
      case "COUNTRY" | "CURRENCY" | "DATA" | "EXCHANGE" | "LANGUAGE" |
           "MULTIPLECHARVALUE" | "MULTIPLEVALUESTRING" | "STRING" | "XMLDATA" |
           "MULTIPLESTRINGVALUE" => "SfFieldString"
      case "INT" | "LENGTH" |  "SEQNUM" | "DAYOFMONTH" | "DAY-OF-MONTH"=> "SfFieldInt"
      case "NUMINGROUP" => "SfNumInGroup"
      case "LOCALMKTDATE" | "DATE" => "SfFieldLocalMktDate" // YYYMMDD  where YYYY=0000-9999 MM=01-12 DD=01-31
      case "MONTHYEAR" | "MONTH-YEAR" => "SfFieldMonthYear" // Valid forms are YYYMMM  YYYYMMDD YYYYMMWW where WW can be w1,w2,w3,w4,w5
      case "TZTIMEONLY" => "SfFieldTzTimeOnly" // HH:MM[:SS][Z[ +- hh[:mm]]]     ISO 8601
      case "TZTIMESTAMP" => "SfFieldTzTimeStamp" // YYYYMMDD-HH:MMM:SS.sss*[Z[ + - hh[:mm]]]   ISO 8601
      case "UTCDATE" | "UTCDATEONLY" => "SfFieldUtcDateOnly" // YYYMMDD  where YYYY=0000-9999 MM=01-12 DD=01-31
      case "UTCTIMEONLY" => "SfFieldUtcTimeOnly" // HH:MM:SS or HH:MM:SS.sss    HH=0-24, MM=00-50, SS=00-60,sss
      case "UTCTIMESTAMP" | "TIME" => "SfFieldUtcTimeStamp" // YYYYMMDD-HH:MM:SS or YYYYMMDD-HH:MM:SS.sss
    }
  }

  private def generateApplyAndDecode : String = {
    generateApply + generateDecode
  }
  private def generateApply : String = {
    if (generateFieldType=="String") ""
    else "\n  def apply(value: String) = try {\n   " + {
      fieldDet.fieldType match {
        case "AMT" => // float
          s" new ${fieldDet.name}Field(value.toFloat)"
        case "BOOLEAN" =>
          s""" new ${fieldDet.name}Field(value match {
              |      case "Y" => true
              |      case "N" => false
              |      case _ => throw new IllegalArgumentException("${fieldDet.name}.apply("+value+"] failed, bad value, expected Y or N.")
              |    })"""
//        case "CHAR" => //"Char"  - some char fields hold strings, so give up on char as a field type
//          s" new ${fieldDet.name}(value.toChar)"
        case "DAYOFMONTH" | "DAY-OF-MONTH" => // "Int"
          s" new ${fieldDet.name}Field(value.toInt)"
        case "FLOAT" => // "Float"
          s" new ${fieldDet.name}Field(value.toFloat)"
        case "INT" => // "Int"
          s" new ${fieldDet.name}Field(value.toInt)"
        case "LENGTH" => // "Int"
          s" new ${fieldDet.name}Field(value.toInt)"
        case "LOCALMKTDATE" | "DATE" => //"LocalDate" // YYYMMDD  where YYYY=0000-9999 MM=01-12 DD=01-31
          s" new ${fieldDet.name}Field(LocalDate.from(SfFixDateFormats.localMktDate.parse(value)))"
        case "MONTHYEAR" | "MONTH-YEAR" => //"LocalDate" // Valid forms are YYYMMM  YYYYMMDD YYYYMMWW where WW can be w1,w2,w3,w4,w5
          s" new ${fieldDet.name}Field(LocalDate.from(SfFixDateFormats.localMktDate.parse(value)))"
        case "NUMINGROUP" => //"Int"
          s" new ${fieldDet.name}Field(value.toInt)"
        case "PERCENTAGE" => //"Float"
          s" new ${fieldDet.name}Field(value.toFloat)"
        case "PRICE" => //"Float"
          s" new ${fieldDet.name}Field(value.toFloat)"
        case "PRICEOFFSET" => //"Float"
          s" new ${fieldDet.name}Field(value.toFloat)"
        case "QTY" => //"Float"
          s" new ${fieldDet.name}Field(value.toFloat)"
        case "SEQNUM" => //"Int"
          s" new ${fieldDet.name}Field(value.toInt)"
        case "TZTIMEONLY" => //"OffsetTime" // HH:MM[:SS][Z[ +- hh[:mm]]]     ISO 8601
          s" new ${fieldDet.name}Field(OffsetTime.from(SfFixDateFormats.tzTimeOnly.parse(value)))"
        case "TZTIMESTAMP" => //"OffsetDateTime" // YYYYMMDD-HH:MMM:SS.sss*[Z[ + - hh[:mm]]]   ISO 8601
          s" new ${fieldDet.name}Field(OffsetDateTime.from(SfFixDateFormats.tzTimeStamp.parse(value)))"
        case "UTCDATE" | "UTCDATEONLY" => //"LocalDate" // YYYMMDD  where YYYY=0000-9999 MM=01-12 DD=01-31
          s" new ${fieldDet.name}Field(LocalDate.from(SfFixDateFormats.utcDateOnly.parse(value)))"
        case "UTCTIMEONLY" => //"LocalTime" // HH:MM:SS or HH:MM:SS.sss    HH=0-24, MM=00-50, SS=00-60,sss
          s" new ${fieldDet.name}Field(LocalTime.from(SfFixDateFormats.utcTimeOnly.parse(value)))"
        case "UTCTIMESTAMP" | "TIME" => //"LocalDateTime" // YYYYMMDD-HH:MM:SS or YYYYMMDD-HH:MM:SS.sss
          s" new ${fieldDet.name}Field(LocalDateTime.from(SfFixDateFormats.utcTimeStamp.parse(value)))"
      }
    } +
      s"""
         |  } catch {
         |    case ex: Exception => throw new IllegalArgumentException("new ${fieldDet.name}("+value.toString+") failed with exception", ex)
         |  } """.stripMargin
  }

  /**
    * Decode is used to turn a coders map of tuples into a map of typed objects.  We can handle
    * any stupid value they stick in the tuple is the idea, eg
    *   def decode(a:Any): Option[NoHopsField] = a match {
    *    case v: Int => Some(NoHopsField(v))
    *    case v: String => Some(NoHopsField(v))
    *    case v: NoHopsField => Some(v)
    *    case _ => None
    *  }
    */
  private def generateDecode : String = {
    val cname = s"${fieldDet.name}Field"

    s"""\n  def decode(a: Option[Any]) : Option[$cname] = a match {
       |    case Some(v) => decode(v)
       |    case _ =>  scala.Option.empty[$cname]
       |  }
       |
       |  def decode(a: Any) : Option[$cname] = a match {
       |    case v: String => Some($cname(v))""".stripMargin + {
      fieldDet.fieldType match {
        case "COUNTRY" | "CURRENCY" | "DATA" | "EXCHANGE" | "LANGUAGE" |
             "MULTIPLECHARVALUE" | "MULTIPLEVALUESTRING" | "STRING" | "XMLDATA" |
             "MULTIPLESTRINGVALUE" => ""
        case "AMT" | "FLOAT" | "PERCENTAGE" | "PRICE" | "PRICEOFFSET" | "QTY"=> // float
          s"""
             |    case v: Float => Some($cname(v))
             |    case v: Double => Some($cname(v.toFloat))
             |    case v: Int => Some($cname(v.toFloat))"""
        case "BOOLEAN" =>
          s"\n    case v: Boolean => Some($cname(v))"
        case "CHAR" => //"Char" - some char fields hold strings, cos fix is stupid
          s"\n    case v: Char => Some($cname(v.toString))"
        case "INT" | "LENGTH" | "NUMINGROUP" | "SEQNUM" | "DAYOFMONTH" | "DAY-OF-MONTH"=> // "Int"
          s"\n    case v: Int => Some($cname(v))"
        case "LOCALMKTDATE" | "MONTHYEAR" | "MONTH-YEAR" | "UTCDATE" | "UTCDATEONLY" | "DATE"=> //"LocalDate" // Valid forms are YYYMMM  YYYYMMDD YYYYMMWW where WW can be w1,w2,w3,w4,w5
          s"\n    case v: LocalDate => Some($cname(v))"
        case "TZTIMEONLY" => //"OffsetTime" // HH:MM[:SS][Z[ +- hh[:mm]]]     ISO 8601
          s"\n    case v: OffsetTime => Some($cname(v))"
        case "TZTIMESTAMP" => //"OffsetDateTime" // YYYYMMDD-HH:MMM:SS.sss*[Z[ + - hh[:mm]]]   ISO 8601
          s"\n    case v: OffsetDateTime => Some($cname(v))"
        case "UTCTIMEONLY" => //"LocalTime" // HH:MM:SS or HH:MM:SS.sss    HH=0-24, MM=00-50, SS=00-60,sss
          s"\n    case v: LocalTime => Some($cname(v))"
        case "UTCTIMESTAMP" | "TIME" => //"LocalDateTime" // YYYYMMDD-HH:MM:SS or YYYYMMDD-HH:MM:SS.sss
          s"\n    case v: LocalDateTime => Some($cname(v))"
      }
    } +
      s"""
         |    case v: $cname => Some(v)
         |    case _ => scala.Option.empty[$cname]
         |  } """.stripMargin
  }

}
